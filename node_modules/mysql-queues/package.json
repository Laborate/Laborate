{
  "author": {
    "name": "Blake Miner",
    "email": "miner.blake@gmail.com",
    "url": "http://www.blakeminer.com"
  },
  "name": "mysql-queues",
  "description": "Wraps 'mysql' to provide mulitple query queues, allowing support for multiple statements and transactions.",
  "version": "0.3.5",
  "homepage": "https://github.com/bminer/node-mysql-queues",
  "repository": {
    "type": "git",
    "url": "git://github.com/bminer/node-mysql-queues.git"
  },
  "contributors": [
    {
      "name": "Tom Atkinson",
      "email": "atkinson.tommy@neosoft.ba"
    },
    {
      "name": "Kris Reeves",
      "email": "krisreeves@searchfanatics.com"
    }
  ],
  "main": "index.js",
  "engines": {
    "node": ">=0.4.0"
  },
  "dependencies": {
    "mysql": ">=0.9.5"
  },
  "bugs": {
    "url": "https://github.com/bminer/node-mysql-queues/issues"
  },
  "devDependencies": {},
  "keywords": [
    "mysql",
    "transaction",
    "multiple statements",
    "queue",
    "query",
    "database"
  ],
  "readme": "# node-mysql-queues\n\nAdd your own node-mysql query queues to support transactions and multiple statements.\n\nFor use with Node.JS and node-mysql: https://github.com/felixge/node-mysql\n\n## Install\n\n`npm install mysql-queues`\n\n## Usage\n\n```javascript\nvar mysql = require('mysql');\nvar client = mysql.createClient({\n\tuser: 'root',\n\tpassword: 'root'\n});\n//Enable mysql-queues\nvar queues = require('mysql-queues');\nconst DEBUG = true;\nqueues(client, DEBUG);\n//Start running queries as normal...\nclient.query(...);\n\n//Now you want a separate queue?\nvar q = client.createQueue();\nq.query(...); \nq.query(...);\nq.execute();\n\nclient.query(...); //Will not execute until all queued queries (and their callbacks) completed.\n\n//Now you want a transaction?\nvar trans = client.startTransaction();\ntrans.query(\"INSERT...\", [x, y, z], function(err, info) {\n\tif(err)\n\t\ttrans.rollback();\n\telse\n\t\ttrans.query(\"UPDATE...\", [a, b, c, info.insertId], function(err) {\n\t\t\tif(err)\n\t\t\t\ttrans.rollback();\n\t\t\telse\n\t\t\t\ttrans.commit();\n\t\t});\n});\ntrans.execute();\n//No other queries will get executed until the transaction completes\nclient.query(\"SELECT ...\") //This won't execute until the transaction is COMPLETELY done (including callbacks)\n\n//Or... as of version 0.3.0, you can do this...\nvar trans = client.startTransaction();\nfunction error(err) {\n\tif(err && !trans.rolledback) {trans.rollback(); throw err;}\n}\ntrans.query(\"DELETE...\", [x], error);\nfor(var i = 0; i < n; i++)\n\ttrans.query(\"INSERT...\", [ y[i] ], error);\ntrans.commit(); //Implictly calls resume(), which calls execute()\n/* In the case written above, COMMIT is placed at the end of the Queue, yet the\nentire transaction can be rolled back if an error occurs. Nesting these queries\nwas not required. */\n\n```\nEven multiple Queues work! They get executed in the order that `execute()` is called.\n\n## How it works\n\n* If I'm a client.query() call or a Queue.execute() call...\n\t* If a Queue is currently executing\n\t\t* Place me on the main queue to be executed\n\t* Otherwise, Execute me now\n\t\t* Run all queries in the Queue in order\n\t\t* Wait for all query callbacks to complete. When they all complete, continue.\n\t\t* If the callback added more queries to this Queue, then jump to \"Execute me now\"\n\t\t* Otherwise\n\t\t\t* If this Queue is a transaction that has not been committed, then\n\t\t\tcommit it now and issue a warning message.\n\t\t\t* Finally, Return control to the main queue by executing all queued queries\n\n## API\n\n### client.query(sql, [params, cb])\n\nUse normally. Same as node-mysql, except that if a Queue is still pending\ncompletion, this query may be queued for later execution.\n\n### client.createQueue()\n\nCreates a new query Queue.\n\n### client.startTransaction()\n\nCreates a new query Queue with \"START TRANSACTION\" as the first queued query.\nThe Queue object will also have `commit()` and `rollback()` methods.\n\n### Queue.query(sql, [params, cb])\n\nSame as node-mysql. This query will be queued for execution until `execute()`\nis called on the `Queue`.\n\n### Queue.execute()\n\nExecutes all queries that were queued using `Queue.query`. Until all query\n*callbacks* complete, it is guaranteed that all queries in this Queue\nwill be executed in order, with no other queries intermixed.  That is, during\nexecution of this query Queue, all queries executed using `client.query` will\nbe queued until this Queue is empty and all callbacks of this Queue have\nfinished executing. That means that a query added to a Queue can also queue\na query using `Queue.query`, and it will be executed before any `client.query`\ncall. Thus, nested query queueing is supported in query callbacks, allowing\nsupport for transactions and more.\nSee the source code for further documentation.\n\nCalling `execute()` on an already executing Queue has no effect.\nCalling `execute()` on a paused Queue has no effect. (see `pause()` below)\n\nNote: Once `execute()` is called and all queries have completed, the Queue\nwill be empty again, returning control to either: (a) another Queue that has been\nqueued for execution; or (b) the main node-mysql queue (a.k.a. queries executed\nwith `client.query`). Once a Queue is empty and has finished executing, you may\ncontinue to use `Queue.query` and `Queue.execute` to queue and execute more\nqueries; however, as noted below, you should *never* reuse a Queue created by\n`client.startTransaction`\n\n### Queue.commit()\n\nAvailable only if this Queue was created with `client.startTransaction`.\n\nAs of version 0.3.0, the behavior of `commit()` is:\n\n * If the queue is empty when `commit()` is called, then 'COMMIT' will be\n queued to be excuted immediately. If this behavior is desired, and you\n are not sure if the queue will be empty, simply call `resume()`\n before calling `commit()`.\n * If the queue is not empty when `commit()` is called, then 'COMMIT' will\n be queued for execution when the queue is empty and all query callbacks\n have completed.\n\nCalling `commit()` also implicitly calls `resume()` on the Queue.\n\nYou may only call `commit()` once. Once you call `commit()` on this Queue,\nyou should discard it. To avoid calling `commit()` twice, you can check\nto see if it exists; once you call `commit()`, in most circumstances, the\nfunction is deleted from the Queue object after it is called.\n\nAs of version 0.3.0, it is sometimes\npossible to call `rollback()` even after `commit()` has been called.\nIf 'COMMIT' is queued for execution (i.e. if the queue is *not* empty when\n`commit()` is called), then you may call `rollback()` on this Queue,\nas long as `rollback()` occurs before the 'COMMIT' is executed (i.e. when the\nQueue is empty and all query callbacks have completed).\nYou might use the functionality in a scenario where you only want your query\ncallbacks to call `rollback()` if an error occurred (i.e. a foreign key\nconstraint was violated). If no error occurs, you want to call `commit()`.\nRather than nesting all of these queries to determine whether or not to\ncall `commit()` or `rollback()`, you can simply queue up all of your queries,\ncall `commit()` to queue up a 'COMMIT', and call `rollback()` in your\nquery callbacks if an error occurs.\n\n### Important Note!\n\nIf you do not call `commit()` or `rollback()` and the Queue has completed\nexecution, `commit()` will be called automatically to end the transaction;\nhowever, one should **NOT** rely on this behavior. In fact, mysql-queues\nwill print nasty warning messages if you do not explicitly `commit()` or\n`rollback()` a transaction.\n\n### Queue.rollback()\n\nAvailable only if this Queue was created with `client.startTransaction`.\nThis executes 'ROLLBACK' immediately and purges the remaining queries in the\nqueue.\n\nYou may only call `rollback()` once. To avoid calling it twice, you can\ncheck to see if it exists; once you call `rollback()`, the function is\ndeleted from the Queue object. Also, once you call `rollback()`, you cannot\ncall `commit()`.\n\nNote: Before 0.2.3, `rollback()` would add the 'ROLLBACK' query to the Queue\nand the Queue would continue executing. This was changed in 0.2.3 because it\nis more natural for a ROLLBACK operation to abort the remaining Queue, since\nit will be rolled back anyway. As mentioned above, this also allows you to\nqueue the COMMIT query at the bottom of the queue, and if an error occurs\nbefore the COMMIT, you can safely `rollback()` the entire transaction.\n\n### Queue.pause([maxWaitDuration])\n\nPauses the Queue, preventing it from returning control to the next Queue or\nto the main node-mysql Queue. You can call `resume()` to resume the Queue,\nor if the Queue is a transaction, `commit()` or `rollback()` will\nautomatically resume the Queue.\n\nBy default, the Queue will remain paused until you call `resume()` or end\nthe transaction; however, you may set an optional maximum wait duration,\nwhich will prevent the Queue from pausing for too long.\n\n*CAUTION:* A paused Queue will block all queries for this connection.\n*Use with care.*\n\nPausing a Queue is useful to make additional asynchronous calls within a\nquery callback. An example of this is shown below.\n\n### Queue.resume()\n\nResumes Queue execution. This function basically unpauses the Queue and\ncalls `execute()`.\n\n### require('mysql-queues')(client, debug)\n\nAttaches mysql-queues to the mysql client. When `debug` mode is enabled,\ndebugging messages are printed to standard error when certain exceptions occur.\nWhen you queue a query, the call stack becomes somewhat useless, and it can\nbecome difficult to determine which query is causing a problem. The debug\nfeature allows you to more easily determine which query that caused a problem.\n\n## Don't do this...\n\n```javascript\n//You may be tempted to do this...\nvar fs = require('fs');\nvar trans = db.startTransaction();\ntrans.query(\"INSERT ...\", [...], function(err, info) {\n\tfs.readFile(\"foobar.txt\", function(err, data) {\n\t\t//By now, it's too late to use `trans`\n\t\tif(data == \"something\")\n\t\t\ttrans.commit();\n\t\telse\n\t\t\ttrans.rollback();\n\t});\n\t//The query callback is now done!! This is your last chance\n\t//to call `commit` or `rollback`\n}).execute();\n```\n\nIn the case above, an asynchronous call was placed in the query callback.\nThis won't work as expected. The query callback completes and automatically\nexecutes `commit()` before the asychronous filesystem call completes. In this\nexample, you will get a warning message, your transaction will be committed\nno matter what, and your program may throw an exception after the I/O\noperation completes (because neither `commit()` nor `rollback()` can be\ncalled more than once).\n\nTo be clear, the scope of this problem is *not* limited by asynchronous\nfile I/O operations; any asychronous call can cause this problem - even a\nquery to another database will cause this problem (i.e. if you execute a\nseries of MySQL queries and then update Redis, for example)\n\n### Fortunately, there are a few solutions...\n\nPossible solutions include: (in order of personal preference)\n\n * Performing your asynchronous operation BEFORE you execute any queued\n queries (i.e. we could have read \"foobar.txt\" first, then executed the query).\n I understand... most of the time, this is not possible.\n * Call `Queue.pause()` right before the asynchrous operation. This is the\n easy way out, but it comes at a small cost. If you pause a Queue, no query\n can be executed during the asynchronous operation. So, for scalability\n reasons, be sure that your asynchronous operation runs quickly (i.e. a Redis\n command or something). Don't do any video encoding on a 1 GB file.\n * Use synchronous I/O operations (i.e. readFileSync in this case). This\n is \"just as bad\" as calling `Queue.pause()` because the query execution is\n paused during the synchronous operation, which will take just as long.\n But, this works, too.\n\nAnd finally, to be clear, you are allowed to do asynchronous calls within the\nquery callback of a transaction. You just need to `commit()` or `rollback()`\nor `pause()` beforehand because the Queue will be empty by the time the\nasynchronous operation completes.\n\n## Questions / Comments / Bugs\n\nPlease feel free to contact me via GitHub, send pull requests, open issues, etc.\n\nI am open to suggestions and criticisms.\n",
  "readmeFilename": "README.md",
  "_id": "mysql-queues@0.3.5",
  "dist": {
    "shasum": "06ebc7b1a48667f7839ff0677b5787b5e4894227"
  },
  "_from": "mysql-queues"
}
